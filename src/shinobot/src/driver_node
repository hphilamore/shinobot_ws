#!/usr/bin/env python

import rospy
from std_msgs.msg import String
from std_msgs.msg import Float64
import RPi.GPIO as GPIO
import time
from time import sleep
import message_filters
# Set the GPIO modes
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

class Driver():
    def __init__(self, 
            pinMotorAForward,
            pinMotorABackward,
            pinMotorBForward,
            pinMotorBBackward,
            pinMotorAEnable,
            pinMotorBEnable
            ):

        # Set variables for the GPIO motor pins
        self.pinMaF = pinMotorAForward # 10
        self.pinMaB = pinMotorABackward # 9
        self.pinMbF = pinMotorBForward # 8
        self.pinMbB = pinMotorBBackward # 7
        self.EnableA = pinMotorAEnable # 21
        self.EnableB = pinMotorBEnable # 20

        # How many times to turn the pin on and off each second
        self.Frequency = 20
        # How long the pin stays on each cycle, as a percent (here, it's 30%)
        self.DutyCycle = 30
        # Setting the duty cycle to 0 means the motors will not turn
        self.Stop = 0

        # Time for obstacle avoid operations
        self.Treverse = 2
        self.Tturn = 2 

        self.command = 'S'
        self.distance = None 

    def GPIOsetup(self):
        # Set the GPIO Pin mode to be Output
        GPIO.setup(self.pinMaF, GPIO.OUT)
        GPIO.setup(self.pinMaB, GPIO.OUT)
        GPIO.setup(self.pinMbF, GPIO.OUT)
        GPIO.setup(self.pinMbB, GPIO.OUT)
        GPIO.setup(self.EnableA, GPIO.OUT)
        GPIO.setup(self.EnableB, GPIO.OUT)

        # Set the GPIO to software PWM at 'Frequency' Hertz
        pwmMaF = GPIO.PWM(self.pinMaF, Frequency)
        pwmMaB = GPIO.PWM(self.pinMaB, Frequency)
        pwmMbF = GPIO.PWM(self.pinMbF, Frequency)
        pwmMbB = GPIO.PWM(self.pinMbB, Frequency)

        # Start the software PWM with a duty cycle of 0 (i.e. not moving)
        pwmMaF.start(self.Stop)
        pwmMaB.start(self.Stop)
        pwmMbF.start(self.Stop)
        pwmMbB.start(self.Stop)


    def Enable (self):  
     GPIO.output(self.EnableA, 1)
     GPIO.output(self.EnableB, 1)

    # Turn all motors off
    def StopMotors(self):
        pwmMaF.ChangeDutyCycle(self.Stop)
        pwmMaB.ChangeDutyCycle(self.Stop)
        pwmMbF.ChangeDutyCycle(self.Stop)
        pwmMbB.ChangeDutyCycle(self.Stop)

    # Turn both motors forwards
    def Forwards(self):
        pwmMaF.ChangeDutyCycle(self.DutyCycle)
        pwmMaB.ChangeDutyCycle(self.Stop)
        pwmMbF.ChangeDutyCycle(self.DutyCycle)
        pwmMbB.ChangeDutyCycle(self.Stop)

    # Turn both motors backwards
    def Backwards(self):
        pwmMaF.ChangeDutyCycle(self.Stop)
        pwmMaB.ChangeDutyCycle(self.DutyCycle)
        pwmMbF.ChangeDutyCycle(self.Stop)
        pwmMbB.ChangeDutyCycle(self.DutyCycle)

    # Turn left
    def Left(self):
        pwmMaF.ChangeDutyCycle(self.Stop)
        pwmMaB.ChangeDutyCycle(self.DutyCycle)
        pwmMbF.ChangeDutyCycle(self.DutyCycle)
        pwmMbB.ChangeDutyCycle(self.Stop)

    # Turn Right
    def Right(self):
        pwmMaF.ChangeDutyCycle(self.DutyCycle)
        pwmMaB.ChangeDutyCycle(self.Stop)
        pwmMbF.ChangeDutyCycle(self.Stop)
        pwmMbB.ChangeDutyCycle(self.DutyCycle)


    # # Message handler
    # def CommandCallback(commandMessage):
    #     command = commandMessage.data
    #     self.Enable()
    #     if command == 'F':
    #         print('Moving forwards')
    #         self.Forwards()
    #     elif command == 'B':
    #         print('Moving backwards')
    #         self.Backwards()
    #     elif command == 'L':
    #         print('Turning left')
    #         self.Left()
    #     elif command == 'R':
    #         print('Turning right')
    #         self.Right()
    #     elif command == 'S':
    #         print('Stopping')
    #         self.StopMotors()
    #     else:
    #         print('Unknown command, stopping instead')
    #         self.StopMotors()

    def storeCommand(self, data):
        self.command = data.data

    def storeDistance(self, data):
        self.distance = data.data

    # Message handler
    def Callback(self, commandMessage, distanceMessage):
    #def Callback(): 
        print('OK')

        print(commandMessage, type(commandMessage))
        print(distanceMessage, type(distanceMessage))

        command = commandMessage.data
        distance = distanceMessage.data


        Enable()

        if distance < 20:
            # print('Moving forwards')
            # Forwards()
            self.ObstacleAvoid()

        else:

            if command == 'F':
                print('Moving forwards')
                self.Forwards()
            elif command == 'B':
                print('Moving backwards')
                self.Backwards()
            elif command == 'L':
                print('Turning left')
                self.Left()
            elif command == 'R':
                print('Turning right')
                self.Right()
            elif command == 'S':
                print('Stopping')
                self.StopMotors()
            else:
                print('Unknown command, stopping instead')
                self.StopMotors()


    # def callback(data):
        
    #     rospy.loginfo(rospy.get_caller_id() + "I heard %s", data.data)

    #     command = data.data

    #     Enable()

    #     if command < 20:
    #         # print('Moving forwards')
    #         # Forwards()
    #         self.ObstacleAvoid()
    #     else:
    #         print('Moving forwards')
    #         self.Forwards()


    # def storeCommand(data):
    #     global command 
    #     command = data.data

    # def storeDistance(data):
    #     global distance
    #     distance = data.data


    def ObstacleAvoid(self): 
        # Back off a little 
        inittime = time.time() 
        now = time.time() 

        print("Reversing...") 
        while (now - inittime) <= Treverse:    
            self.Backwards() 
            now = time.time() 

        self.StopMotors() 
        inittime = time.time() 
        now = time.time() 

        print("Turning...") 
        while (now - inittime) <= Tturn:
            self.Right() 
            now = time.time() 

        self.StopMotors() 


    def driver(self):

        rospy.init_node('driver')
        rospy.Subscriber('command', String, self.storeCommand)
        rospy.Subscriber('distance_sense', Float64, self.storeDistance)
        print(self.command)
        print(self.distance) 
        # command = message_filters.Subscriber('command', String)
        # distance = message_filters.Subscriber('distance_sense', Float64)
        # ts = message_filters.ApproximateTimeSynchronizer([command, distance], 5, 1, allow_headerless=True)
        # ts.registerCallback(Callback)
        rospy.spin()


# rospy.Subscriber('command', String, CommandCallback)

# rospy.Subscriber("distance_sense", Float64, callback)




# msgCommand = rospy.Subscriber('command', String)
# print(msgCommand.data, type(msgCommand.data))
# msgDistance = rospy.Subscriber("distance_sense", Float64)
# print(msgDistance.data, type(msgDistance.data))



# Callback(msgCommand, msgDistance)
#Callback()

if __name__ == '__main__':
    driver = Driver(10, 9, 8, 7, 21, 20)
    try:
        driver.driver()
    except rospy.ROSInterruptException:
        pass
    except KeyboardInterrupt:
        # Reset GPIO settings 
        print('Shutting down: stopping motors')
        StopMotors()
        GPIO.cleanup()
        sys.exit()


