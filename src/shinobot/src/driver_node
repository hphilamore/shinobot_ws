#!/usr/bin/env python
from __future__ import print_function
import rospy
#import dual_g2_hpmd_rpi
from dual_g2_hpmd_rpi import Motor, Motors, motors, MAX_SPEED
import time
from time import sleep
from std_msgs.msg import String
from std_msgs.msg import Float64
import message_filters

# Define a custom exception to raise if a fault is detected.
class DriverFault(Exception):
    def __init__(self, driver_num):
        self.driver_num = driver_num

def raiseIfFault():
    if motors.motor1.getFault():
        raise DriverFault(1)
    if motors.motor2.getFault():
        raise DriverFault(2)

# # Set up sequences of motor speeds.
# test_forward_speeds = list(range(0, MAX_SPEED, 1)) + \
#   [MAX_SPEED] * 200 + list(range(MAX_SPEED, 0, -1)) + [0]  

# test_reverse_speeds = list(range(0, -MAX_SPEED, -1)) + \
#   [-MAX_SPEED] * 200 + list(range(-MAX_SPEED, 0, 1)) + [0]  

class Driver():
    def __init__(self):

        # Set variables for the GPIO motor pins
        self.motors = Motors()

        # Time for obstacle avoid operations
        self.Treverse = 2
        self.Tturn = 2 

        # Control variables 
        self.command = 'S'
        self.distance = None 

    def Stop(self):
        motors.motor1.setSpeed( 0 )
        motors.motor2.setSpeed( 0 )
        raiseIfFault()
        sleep(0.002)


    def Forwards(self):
        motors.motor1.setSpeed( MAX_SPEED/4 )
        motors.motor2.setSpeed( MAX_SPEED/4 )
        raiseIfFault()
        sleep(0.002)


    def Backwards(self):
        motors.motor1.setSpeed( -MAX_SPEED/4 )
        motors.motor2.setSpeed( -MAX_SPEED/4 )
        raiseIfFault()
        sleep(0.002)


    def Left(self):
        motors.motor1.setSpeed( MAX_SPEED/4 )
        motors.motor2.setSpeed( -MAX_SPEED/4 )
        raiseIfFault()
        sleep(0.002)


    def Right(self):
        motors.motor1.setSpeed( -MAX_SPEED/4 )
        motors.motor2.setSpeed( MAX_SPEED/4 )
        raiseIfFault()
        sleep(0.002)


    def storeCommand(self, data):
        rospy.loginfo(rospy.get_caller_id() + "Command is %s", data.data)
        self.command = data.data
        print(self.command, self.distance)
        self.callback()


    def storeDistance(self, data):
        rospy.loginfo(rospy.get_caller_id() + "Distance is %s", data.data)
        self.distance = data.data
        print(self.distance, self.command)
        self.callback()

    # Message handler
    def callback(self):

        # if self.distance < 20:
        #     # print('Moving forwards')
        #     # Forwards()
        #     self.obstacleAvoid()

        # else:

        if self.command == 'F':
            print('Moving forwards')
            self.Forwards()
        elif self.command == 'B':
            print('Moving backwards')
            self.Backwards()
        elif self.command == 'L':
            print('Turning left')
            self.Left()
        elif self.command == 'R':
            print('Turning right')
            self.Right()
        elif self.command == 'S':
            print('Stopping')
            self.Stop()
        else:
            print('Unknown command, stopping instead')
            self.Stop()



    def obstacleAvoid(self): 
        # Back off a little 
        inittime = time.time() 
        now = time.time() 

        print("Reversing...") 
        while (now - inittime) <= self.Treverse:    
            self.Backwards() 
            now = time.time() 

        self.Stop() 
        inittime = time.time() 
        now = time.time() 

        print("Turning...") 
        while (now - inittime) <= self.Tturn:
            self.Right() 
            now = time.time() 

        self.Stop() 



    def driver(self):
        rospy.init_node('driver')
        rospy.Subscriber('command', String, self.storeCommand, queue_size=1)
        rospy.Subscriber('distance_sense', Float64, self.storeDistance, queue_size=1)
        rospy.spin()

        



if __name__ == '__main__':
    driver = Driver()
    try:
        driver.driver()


    except rospy.ROSInterruptException:
        pass

    except KeyboardInterrupt:
        # Reset GPIO settings 
        print('Shutting down: stopping motors')
        #StopMotors()
        motors.forceStop()
        sys.exit()

